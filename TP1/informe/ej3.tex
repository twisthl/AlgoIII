\subsection{Descripci\'on del problema}

\noindent
Se pide resolver la problem\'atica que tiene una empresa transportadora en reducir \'optimamente la cantidad de camiones que utiliza para transportar una serie de productos qu\'imicos. \\
Dada una cierta cantidad n de productos qu\'imicos, tal que para cada par de combinaciones de productos se corresponde un valor num\'erico mayor o igual a 0 llamado coeficiente de peligrosidad (un coeficiente por cada par), debemos reducir al m\'inimo la cantidad de camiones que utilizamos para transportar los n productos siendo que existe un valor M, num\'erico mayor o igual a 0, que llamaremos umbral de peligrosidad, y cuyo valor debe ser mayor o igual a la suma de todas las peligrosidades dentro de un cami\'on. La suma de todas las peligrosidades dentro de un camion, como esta expresado, es lo mismo que la suma de todos los coeficientes de peligrosidad de todas las combinaciones de pares de productos que se encuentren en el cami\'on. 
\bigskip

\noindent
Ejemplo1: \\
$n = 2$ y $M = 0$ \\ 
$peligrosidad_{(0,1)} = 1$ \\
(la peligrosidad de los dos quimicos juntos es de 1) \\

\noindent
La cantidad m\'inima de camiones necesarios para transportar los qu\'imicos es 2. La raz\'on es que la peligrosidad de la combinaci\'on de los dos qu\'imicos es 1. Luego si la peligrosidad de un camion es la suma de todas sus peligrosidades por combinaciones de qu\'imicos y contiene a los qu\'imicos 0 y 1, la peligrosidad del cami\'on es 1. Y 1 es mayor a M, por lo tanto poner estos dos quimicos en el mismo cami\'on no es una opci\'on. \\
La \'unica opci\'on de poner los dos quimicos separados, osea en distintos camiones. Como s\'olo teniamos 2 qu\'imicos y ambos est\'an en alg\'un cami\'on, esta es la soluci\'on. 
\bigskip
\bigskip

\noindent
Ejemplo2: \\
$n = 3$ y $M = 1$ \\
$peligrosidad_{(1,2)} = 2$ \\
$peligrosidad_{(0,1)} = 0$ \\
$peligrosidad_{(0,2)} = 0$ \\

\noindent
En este caso la cantidad m\'inima de camiones es 2. \\
Se tiene que la \'unica combinaci\'on de quimicos que agrega peligrosidad a un cami\'on es la de los qu\'imicos 1 y 2. Estos dos qu\'imicos no pueden estar juntos, deben estar separados en 2 camiones distintos ya que su combinaci\'on supera a la cota de peligrosidad M. Establecemos entonces que debemos tener desde ya dos camiones, uno para el qu\'imico 1 y otro para el 2. 
Analizando el qu\'imico 0 podemos ver que no importa con qu\'e qu\'imico este combinado, no agrega peligrosidad a un cami\'on. Puede ser ubicado en cualquiera de los dos camiones, no hace falta agregar otro cami\'on para ubicar este qu\'imico.
\bigskip
\bigskip

\noindent
Ejemplo3: \\
$n = 3$ y $M = 50$ \\
$peligrosidad_{(1,2)} = 1$ \\
$peligrosidad_{(0,1)} = 2$ \\ 
$peligrosidad_{(0,2)} = 1$ \\ 

\noindent
En este caso la cantidad m\'inima de camiones es 1. Ya que la peligrosidad de poner los 3 qu\'imicos en un mismo cami\'on es la peligrosidad de (1,2) + (0,1) + (0,2) = 1 + 2 + 1 = 4 < M (=50). Y dado que no hay soluci\'on m\'as chica que poner todos los qu\'imicos en 1 s\'olo cami\'on, \'esta es la mejor soluci\'on.
 
\subsection{Resoluci\'on}

\noindent
Para resolver el problema utilizamos la t\'ecnica de backtracking. \\
Comenzamos creando un primer cami\'on y ubicando un qu\'imico en \'el. Luego llamamos a la funci\'on recursiva descripta a continuaci\'on. \\
La funci\'on recursiva hace lo siguiente: \\
Se fija si todos los qu\'imicos estan ubicados en alg\'un cami\'on, \\
1- De ser verdadero resulta que nos encontramos con una soluci\'on posible al problema. Se testea que esta posible soluci\'on sea mejor a una soluci\'on que ya est\'e guardada (ser mejor en este caso significa que tenga menor n\'umero de camiones). Si es efectivamente mejor o no hab\'ia soluci\'on guardada, se guarda la soluci\'on nueva pisando a la guardada si lo hubiese. \\
2- De ser falso, resulta que quedan quimicos por ubicar. Entonces lo que hace es iterar sobre todos los qu\'imicos no ubicados en alg\'un cami\'on y por cada quimico iterar sobre los camiones ya creados y 1 camion nuevo sin quimicos. En cada cada iteracion se prueba si la peligrosidad resultado de ubicar el quimico en el camion es menor o igual a la cota M. De ser as\'i se coloca el quimico en el camion y se llama nuevamente a la funcion recursiva. Cuando se vuelve de la funcion recursiva se quita el quimico del camion y se continua con la proxima iteraci\'on. \\
Una vez se recorran todas distribuciones posibles, la soluci\'on al problema se encuentra en aquella que est\'e guardada, mencionada anteriormente. \\
\bigskip
\bigskip

\noindent
$\proc{BIOHAZARD(M):}$
\begin{itemize}
	\item Creo el primer cami\'on.
	\item Agrego el qu\'imico con identificador 0 al primer cami\'on.
	\item RECURSION(infoCamiones(*), 1, n)		
\end{itemize} 
\bigskip
\bigskip

\noindent
$\proc{RECURSION(infoCamiones, q(**), M)}$
\begin{itemize}
\item Si est\'an todos los qu\'imicos cargados en alg\'un cami\'on,							
	\begin{itemize}
	\item El estado actual de los qu\'imicos (d\'onde est\'an ubicados) es una posible soluci\'on
	\item Si la cant. de camiones que se est\'an usando en esta posible soluci\'on es menor a la m\'as chica que encontr\'e,
		\begin{itemize}
		\item Guardo esta posible soluci\'on c\'omo la que tiene menos camiones entre todas las ya encontradas.
		\end{itemize}																												
	\item Sino,
		\begin{itemize}
		\item Por cada cami\'on que ya contenga al menos 1 qu\'imico,									
			\begin{itemize}
			\item Si la peligrosidad de agregar el qu\'imico $q$ en \'este cami\'on no supera a M,
				\begin{itemize}
				\item Agrego el qu\'imico $q$ a este cami\'on
				\item $\proc{RECURSION(q++, M)}$
				\item Quito el qu\'imico $q$ de este cami\'on
				\end{itemize}
			\end{itemize}		
		\end{itemize}
		\item Si la poda 2 no est\'a habilitada, o si agregar un cami\'on no hace que la cantidad de camiones sea igual o mayor a la de la soluci\'on guardada, (si la hay, de lo contrario tambi\'en prosigo),
		\begin{itemize}
			\item Creo un nuevo cami\'on.
			\item Agrego el qu\'imico $q$ al nuevo cami\'on.
			\item $\proc{RECURSION(infoCamiones, q++, M)}$	
			\item Quito el qu\'imico $q$ del nuevo cami\'on.
			\item Elimino el nuevo cami\'on.
		\end{itemize}
	\end{itemize}			
\end{itemize}
\bigskip
\noindent
(*): infoCamiones contiene la informaci\'on de cuantos camiones hay creados, cuantos y cuales qu\'imicos contiene y cual es el valor de la peligrosidad del cami\'on con los qu\'imicos que tiene actualmente. \\
(**): $q$ es el identificador de un qu\'imico. Cada qu\'imico contiene un identificador entero sin signo distinto al de otro qu\'imico, utilizando el rango (0,1,2,...,n-1).
\bigskip
\bigskip

\noindent
Implementamos podas para ayudar mejorar los tiempos de ejecuci\'on. Las podas son 2. 

\noindent
La primera poda es no permitir soluciones practicamente iguales. Donde una solucion es practicamente igual a otra si tiene los mismos conjuntos de quimicos ubicados por cami\'on pero est\'an ubicados en diferentes numero de camion. Por ejemplo las siguientes podr\'ian ser dos soluciones $practicamente iguales$:
$2 0 0 1 1$
$2 1 1 0 0$
 
\noindent
La segunda poda es no recorrer ramas tal que pueda deducir que sus hojas y posibles solucion no puedan mejorar la que ya esta guardada como mejor hasta el momento.

\noindent
La implementacion de la primera poda se encuentra en las entranias del algoritmo. Tiene que ver con el orden por el que se iteran los quimicos y qu\'e n\'umero de identificador tienen los nuevos camiones creados.

\noindent
la implementacion de la segunda poda se encuentra en la funci\'on recursiva, antes de ubicar un quimico en un camion nuevo sin quimicos. Se consulta si la cantidad de camiones que hay creados m\'as el nuevo creado es igual o mayor a la cantidad que tiene la mejor solucion. Si efectivamente alcanza o supera esa cantidad entonces se poda la rama, es decir no se ubica el qu\'imico al camion nuevo, y en vez contin\'ua saliendo de la funci\'on.


\subsection{PseudoCorrectitud de la resoluci\'on}

\noindent
Justificaci\'on breve de algunos detalles de la resoluci\'on.

\noindent
En cuanto a las podas, podemos decir que la primera es trivial y no requiere detalle.

Segunda poda: 
Como dijimos la soluci\'on de esta poda se encuentra en los numeros de identificadores de los qu\'imicos y qu\'e numero de identificador se le da a un cami\'on recientemente creado.
Cada qu\'imico tiene un numero de identificador distinto que va desde 0 hasta n-1. En las iteraciones se itera por cada qu\'imico no ubicado, desde el de menor numero de identificador hasta el mayor. 
Cada cami\'on nuevo tiene un n\'umero de identificador de +1 al \'ultimo creado. 
El efecto de resolverlo de \'esta manera es que si un qu\'imico se ubica en un cami\'on nuevo, s\'olo los qu\'imicos de n\'umero de identificador mayor se pueden ubicar en el mismo grupo. Y si por cada cami\'on nuevo su n\'umero de identificador es mayor, el efecto es el siguiente:
Cada qu\'imico $q$ est\'a ubicado en el n\'umero de cami\'on $X$, tal que el n\'umero de qu\'imico m\'as chico del grupo del qu\'imico $q$ es el numero $X$ en la lista ordenada de menor a mayor de los menores identificadores de qu\'imicos de cada grupo. Dado que todos los qu\'imicos tienen un n\'umero de identificador distinto \'existe una univoca soluci\'on que cumpla estas caracteristicas, no hay soluciones practicamente iguales.


Y en cuanto a la segunda poda tiene una justificaci\'on bastante simple. Dada cualquier solucion incompleta o rama en construcci\'on, es decir que tenga qu\'imicos en algunos camiones pero que todavia tenga qu\'imicos sin agregar a alg\'un camion, la cantidad de camiones no puede decrementar mientras no se quiten productos de camiones. Ramificar significa agregar un producto, ya sea a un camion que ya se encuentra en uso u a otro nuevo. Luego si ya hay una soluci\'on guardada con la misma cantidad de camiones o menor a la de una solucion incompleta, la mejor soluci\'on a la que la rama puede aspirar no es mejor a la guardada, ya que la cantidad de camiones no puede decrementar y por lo tanto no puede llegar a tener menos camiones que la guardada.


\subsection{Complejidad del algoritmo}




$\proc{BIOHAZARD(n)}$
\begin{itemize}
	\item Inicializar matriz de coeficientes de peligrocidad,		$O(n^2)$
	\item crear primer camion y meter el primer quimico,		$O(1)$
	\item RECURSION(n)										$O(R(n))$
\end{itemize}		$O(R(n) + n^2 )$ 



$\proc{RECURSION(k)}$
\begin{itemize}
\item Si es solucion y es la mejor la guardo,						$O(n)$
\item Por cada producto quimico de menor a mayor, 						$*O(n)$
	\begin{itemize}
	\item Si no esta agregado a ningun otro camion,						$O(1)$			
		\begin{itemize}
		\item Si la peligrosidad de agregar no es mas grande que M,		$O(n)$
			\begin{itemize}
			\item agregar el producto al camion							$O(1)$
			\item RECURSION(k-1)											$O(R(k-1))$
			\item eliminar el producto del camion							$O(1)$
			\end{itemize}													$O(nR)$
		\end{itemize}													$O(n^2R)$
	\end{itemize}															$O(n^2R)$
\item Si la solucion final podria ser mejor a la mejor por ahora,				$O(1)$
	\begin{itemize}
	\item Por cada producto quimico de menor a mayor,								$O(n)$
		\begin{itemize}
		\item si no esta agregado													$O(1)$
			\begin{itemize}
			\item crear un nuevo camion y agregar el producto ese camion			$O(1)$
			\item RECURSION(k-1)													$O(R(k-1))$
			\item borrar el camion nuevo y quitar el producto de ese camion		$O(1)$
			\end{itemize}						$O(R)$
		\end{itemize}						$O(nR)$
	\end{itemize}						$O(nR)$
\end{itemize}	$O(n^2R(k-1))$


Con $k$ incializado en $n$:
$R(k) = n^2*R(k-1) = n^2*n^2*R(k-2) = ... = (n^2)^n = (n^n)^2$
Esta es una cota teorica de la complejidad del algoritmo sin podar en repeticion de combinaciones. 
En el pseudoc\'odigo mostramos $*O(n)$ con $*$ indicando que se puede acotar todav\'ia m\'as. Evitando combinaciones se itera solamente por los productos no agregados que tengan identificador mas grande que el ultimo agregado.


\subsection{C\'odigo fuente}

\lstset{language=C++,
                basicstyle=\ttfamily\footnotesize,
                keywordstyle=\color{blue}\ttfamily,
                stringstyle=\color{red}\ttfamily,
                commentstyle=\color{green}\ttfamily,
                morecomment=[l][\color{magenta}]{\#},
                breaklines=true
}
\begin{lstlisting}

Ej3::Ej3(int n, int M, vector<vector<int> > peligrosidad, bool podaHabilitada, bool mostrarInfo){

	this->n = n;
	this->M = M;
	this->peligrosidad = peligrosidad;

	this->podaHabilitada = podaHabilitada;
	this->mostrarInfo = mostrarInfo;

	this->minCamiones = INF;
}

double Ej3::resolverBiohazard(){
	timespec ts_beg, ts_end;
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts_beg);


	// BEGIN BIOHAZARD
	vector<unsigned int> carga;
	for (int i = 0; i < n; i++){
		carga.push_back(-1);
	} 
	list<Camion> camiones;
	Quimico primerQuimico = 0;
	Camion camionNuevo(0, primerQuimico);
	camiones.push_back(camionNuevo);
	carga[primerQuimico] = camionNuevo.nro;
	combinar2(camiones, primerQuimico+1, carga);
	// END BIOHAZARD

	cout << "Tiempo de ejecucion: " << endl;
	clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts_end);
	double time = (ts_end.tv_sec - ts_beg.tv_sec) + (ts_end.tv_nsec - ts_beg.tv_nsec) / 1e9;
	cout << time << " sec" << endl;
	cout << endl;

	return time;
}

void Ej3::combinar2(list<Camion> &camiones, Quimico quimicoACargar, vector<unsigned int> &carga){

	//Lo siguiente equipara a decir: Si no hay mas quimicos para cargar..
	if (quimicoACargar == this->n) {
		if (minCamiones > camiones.size()){
			if (this->mostrarInfo) mostrarSolucion(carga, camiones.size());
			this->minCamiones = camiones.size();
			this->cargaMinima = carga;	
		}
		return;
	}

	list<Camion>::iterator itCamion;
	for (itCamion = camiones.begin(); itCamion != camiones.end(); itCamion++){
		int peligrosidadAgregada = calcularPeligrosidadAgregada(*itCamion, quimicoACargar);
		if (this->M >= (itCamion->peligrosidad + peligrosidadAgregada)){

			itCamion->quimicos.push_back(quimicoACargar);
			itCamion->peligrosidad += peligrosidadAgregada;
			carga[quimicoACargar] = itCamion->nro;
			combinar2(camiones, quimicoACargar+1, carga);
			carga[quimicoACargar] = -1;
			itCamion->peligrosidad -= peligrosidadAgregada;
			itCamion->quimicos.pop_back();
		}
	}
	
	// Podamos las combinaciones de carga de quimicos que ya no pueden superar a la mejor solucion obtenida hasta ahora
	if (!podaHabilitada || camiones.size() + 1 < this->minCamiones) {
		Camion camionNuevo(camiones.size(), quimicoACargar);
		camiones.push_back(camionNuevo);
		carga[quimicoACargar] = camionNuevo.nro;
		combinar2(camiones, quimicoACargar+1, carga);
		carga[quimicoACargar] = -1;
		camiones.pop_back();
	}
}

// Calcula la peligrosidad que agrega el combinar un nuevo quimico a un camion con una cierta distribucion.
int Ej3::calcularPeligrosidadAgregada(Camion &camion, Quimico quimico){
	int peligrosidadAgregada = 0;
	list<Quimico>::iterator it;
	for (it = camion.quimicos.begin(); it != camion.quimicos.end(); it++){
		peligrosidadAgregada += this->peligrosidad[quimico][*it];
	}
	return peligrosidadAgregada;
}

void Ej3::mostrarSolucion(){
	cout << "Mejor solucion: " << endl;
	mostrarSolucion(this->cargaMinima, this->minCamiones);
}

void Ej3::mostrarSolucion(vector<unsigned int> &carga, unsigned int cantCamiones){
	cout << cantCamiones << " ";
	for (int i = 0; i < this->n; i++){
		cout << carga[i] << " ";
	}
	cout << endl << endl;
}

string Ej3::dameSolucion(){
	string solucion = std::to_string(this->minCamiones) + " ";
	for (int i = 0; i < this->n; i++){
		solucion += std::to_string(this->cargaMinima[i]) + " ";
	}
	return solucion;
}

%\end{lstlisting}

\subsection{Casos de prueba}

\subsection{Performance}
