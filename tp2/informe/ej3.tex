\subsection{Descripci\'on del problema}

En el problema somos una empresa que provee soluciones algoritmicas para problemas sobre redes informaticas. Tenemos un cliente que desea implementar un servicio particular en una red de computadoras ya existente.
Lo que se desea es crear en esta red una especie de red de computadoras donde los servidores deben formar un backbone 


\newpage

\subsection{Resoluci\'on}

Para resolver el problema, primero observamos que este se podia modelar mediante grafos y simplificarlo pensandolo como un ejercicio en el que se pide tener a todos los nodos en una sola componente conexa donde tiene que haber un (y solo un) ciclo, y el peso total de todo el grafo debe ser minimo.
\begin{itemize}

\end{itemize}


\newpage

\subsection{Demostraci\'on de la resoluci\'on}

Para demostrar que nuestra resolucion realmente resuelve el problema propuesto haremos una demostracion por partes.

Como ya dijimos, a grandes razgos la forma que proponemos de resolver el problema es correr el algoritmo de Kruskal para obtener un arbol generador mínimo (AGM) a partir de todas las conexiones ya existentes, y luego agregarle a este la conexión de menor costo que no haya sido utilizada. Con lo cual obtenemos el anillo que pasaría a ser parte del anillo de servidores.

Para demostrar que con este procedimiento efectivamente obtenemos una red de servidores de tipo anillo y como efectivamente tratamos a este problema como un problema de grafos, a partir de ahora diremos que las computadoras y servidores son nodos en el grafo, y las conexiones entre ellos serán las aristas, donde el costo de conexión es el peso de estas. Por lo tanto reducimos el problema a obtener un grafo de peso mínimo en el que todos los nodos formen solo una componente conexa y en esta exista un (y solo un) ciclo.

Ahora para ser mas claros separaremos la demostracion en dos partes:

\begin{itemize}
\item Demostraremos que al obtener un AGM y agregarle la menor arista restante del grafo, obtenemos una componente conexa con un ciclo, de peso total óptimo.
\item Para demostrar lo anterior necesitaremos probar que no existe la posibilidad de que nuestra solucion genere un AGM donde pueda existir otro AGM que deje afuera a una arista de menor peso, siendo finalmente una solucion mejor. Por lo tanto en segundo lugar probaremos que cualquier AGM de un mismo grafo siempre esta formado el mismo multiconjunto de pesos de aristas, por lo tanto la arista de menor peso que quede afuera de nuestro AGM siempre será del mismo peso (aunque pueda no ser la misma arista).
\end{itemize}

Por un simple hecho de comodidad comenzaremos demostrando el segundo punto:

Sean $T_1$ y $T_2$ dos AGM del grafo $G$, sean $M_1$ y $M_2$ los conjuntos de aristas que forman $T_1$ y $T_2$ respectivamente. Vamos a suponer que los pesos de las aristas en $M_1$ y $M_2$ son distintos. Sea $W$ el conjunto de aristas que pertenece a $M_1$ y no a $M_2$, y viceversa. \forall $x$ \in $W$, ($x$ \in $M_1$ \wedge $x$ \nin $M_2$) \vee ($x$ \in $M_2$ \wedge $x$ \in $M_1$)
Tomamos de $W$ la arista de menor peso, la llamaremos $e$, y sin perdida de generalidad diremos que $e$ \in $T_1$ \wedge $e$ \nin $T_2$. Podemos decir entonces que todas las aristas que posean menor peso que el de $e$ estan en $T_1$ y en $T_2$.
Como $T_2$ es un AGM si le agregamos una arista, se formar\'a un ciclo que la contiene, llamemoslo $C$. Ahora podemos observar que en este ciclo $C$ debe existir al menos una arista $e'$ tal que $e'$ \nin $T_1$, porque sino seria lo mismo que decir que en $T_1$ hay un ciclo, y este es un AGM. Tambien podemos decir que le peso de $e'$ es mayor o igual al peso de $e$ por la observacion hecha anteriormente, y aqui pueden pasar dos cosas:
\begin{itemize}
\item $e'$ \geq $e$
\end{itemize}
Si $e'$ \geq $e$ entonces podriamos agregar $e$ a $T_2$ y sacar $e'$, finalmente formando un arbol $T_3$ de peso menor que el de $T_2$. Esto es absurdo ya que $T_2$ era un AGM, y no podria haber una arbol de peso menor.

\begin{itemize}
\item $e'$ \eq $e$
\end{itemize}
Si $e'$ \eq $e$, podriamos agarrar la arista de menor peso en $W$ \setminus ${$ $e$ $}$ y repetir el procedimiento.
Como supusimos que los pesos de las aristas en $M_1$ y $M_2$ son distintos, en algun momento debemos llegar a formar un ciclo en $T_2$ tal que en el existe una arista $e'$ de peso mayor que el de $e$, de otra forma W estaria formado por pares de aristas de un mismo peso donde una pertenece a $T_1$ y otra a $T_2$, y esto tambien ser\'ia absurdo, ya que supusimos que los pesos de los conjuntos de $M_1$ y $M_2$ son distintos.

Ahora que sabemos que un AGM esta formado siempre por un conjunto de aristas de los mismos pesos, podemos decir que al tener el conjunto de aristas total $C_1$ y le sacamos las aristas del AGM $C_2$, $C_1$ tambien estara formado por un conjunto de aristas de los mismos pesos para cualquier AGM. Por lo tanto podemos asegurar que la arista de menor peso que queda afuera puede no ser siempre la misma, pero siempre sera del mismo peso.

Con esto podemos demostrar la primer parte:

Como sabemos, por definicion un arbol generador de un grafo $G$ es un arbol que tiene el mismo conjunto de nodos que $G$, y un arbol generador mínimo es un arbol generador tal que el peso total (o longitud) de las aristas es el mínimo posible.
Por lo tanto si queremos tener todas las computadoras conectadas entre si, es normal pensar que queremos tener todos los nodos en una misma componente conexa.
Al mismo tiempo pensamos en un AGM, porque no existe otra forma de tener conectados todos los nodos de un grafo minimizando el peso, sin que este sea un arbol, si este no es un arbol es porque este tiene algun ciclo, entonces podriamos sacar cualquier arista de ese ciclo y finalmente obtendriamos un grafo de peso menor.

Finalmente si conectamos todos los nodos mediante un AGM, podemos decir que es la forma de tener a todos conectados minimizando el peso total de las aristas. Si queremos generar un ciclo en este grafo, solo bastaría con agregar la arista de menor peso que haya quedado fuera del arbol y aquí el porque de la demostracion anterior. Ahí confirmamos que sin importar que AGM me genere Kruskal, la arista de menor peso que quede afuera siempre tendra el mismo peso, por lo tanto no podria existir otro AGM que me deje una arista de peso menor afuera y finalmente este forme una solucion mejor.

Por lo tanto podemos confirmar que obteniendo un AGM y agregandole la arista de menor peso que haya quedado fuera obtenemos una componente conexa con un (y solo un) ciclo tal que el peso total de las aristas sea minimo.


\newpage

\subsection{Complejidad del algoritmo}

La complejidad del algoritmo la plantearemos a partir de varios pseudo-códigos:

\begin{itemize}
\item Complejidad de Kruskal
\item Complejidad de BFS para obtener las aristas pertenecientes al ciclo
\item Complejidad del algoritmo final
\end{itemize}

\subsubsection{Complejidad de Kruskal}


\begin{itemize}
\item $KRUSKAL$
\item Me creo un grafo, $AGM$, vacio donde ire guardando el arbol generador minimo creado.
\item Para cada vertice $v$ en $G$
	\begin{itemize}
	\item Creo un conjunto de pertenencia
	\end{itemize}
\item Mientras no haya agregado $n-1$ aristas y no revise todas las aristas (recorriendo las aristas en orden ascendente segun su peso)
	\begin{itemize}
	\item Si v.a y v.b no pertenecen al mismo conjunto de pertenencia (donde v.a y v.b son los nodos que conecta la arista v)
		\begin{itemize}
		\item Agrego la arista a $AGM$
		\item Actualizo el conjunto de pertenencia de v.b y todos los nodos adyacentes a el.
		\item Sumo 1 a la cantidad de aristas agregadas.
		\end{itemize}
	\item Sino, Si aun no encontre la primer arista excluida del arbol
		\begin{itemize}
		\item Me guardo la arista excluida.
		\end{itemize}
	\end{itemize}
\item devuelvo $AGM$
\end{itemize}


\subsubsection{BFS}

\begin{itemize}
\item Para cada vertice $u$ en $G-{s}$
	\begin{itemize}
	\item Seteo $u$ como no visitado, distancia infinito y predecesor nulo.
	\end{itemize}
\item Seteo $s$ como visitado, distancia 0 (cero), predecesor nulo.
\item Creo una cola $Q$ y encolo $s$
\item Mientras la cola no este vacia
	\begin{itemize}
	\item Desencolo un elemento $s'$
	\item Para cada vertice $v$ adjacente a $s'$
		\begin{itemize}
		\item Si no visite $v$:
			\begin{itemize}
			\item Marco a $v$ como visitado, distancia de $v$ = distancia de $s' + 1$, predecesor = $s'$
			\end{itemize}
		\end{itemize}

	\end{itemize}

\end{itemize}

\begin{itemize}
\end{itemize}

\subsubsection{Complejidad de BFS}
\subsubsection{Complejidad del algoritmo}



\newpage

\subsection{C\'odigo fuente}


\newpage

\subsection{Casos de prueba}

En este ejercicio decidimos hacer los casos de prueba con las siguientes caracteristicas:

\begin{itemize}
\item Caso en el que las conexiones todas las conexiones dadas no forman una sola red conjunta. De esta forma el algoritmo no tiene solución, por lo cual debería devolver "no".
\item Caso con los costos de todas las conexiones distintos. En este caso se devería observar que las conexiones que forman la red son las $n$ conexiones de menor costo, donde $n$ es la cantidad de computadoras de la red.
\item 
\end{itemize}


\newpage

\subsection{Performance}

