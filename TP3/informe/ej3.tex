\subsection{Resoluci\'on}

Para nuestra heurística golosa comenzamos ordenando las aristas por peso de mayor a menor. Una vez obtenida la lista de aristas ordenadas por peso la iteramos escogiendo primero un nodo (arbitrariamente) de la arista más pesada y si la arista aun no se encuentra ubicada, se agrega a un nuevo conjunto siempre y cuando no hayamos sobrepasado la cantidad $k$ de conjuntos creados. En caso de que ya tengamos $k$ conjuntos o en caso de que hayamos terminado de recorrer las aristas se termina el ciclo.
Ahora verificamos si la cantidad de conjuntos creados es menor a $k$, en caso afirmativo habremos ubicado todos los nodos con aristas en alguno de los conjuntos.
Si quedan nodos sin ubicar, estos se agregan a cualquier conjunto, como ya agregamos todos los nodos de grado mayor a uno, los que restan se puede decir que tienen grado 0, por lo tanto, no importa en que conjunto sean agregados, estos no crearán aristas intraparticion y como consecuencia no sumarán peso a ningún conjunto.
Si la cantidad de conjuntos creados es igual a $k$, actuamos de forma diferente, aquí recorremos todas las aristas, actuando solo con las que no hayan sido agregadas a ningún conjunto de la siguiente manera: verificamos cuanto peso agregaría en cada conjunto para luego realmente añadirlo al conjunto que sume menos peso, en caso de encontrar uno en el que no cree aristas intraparticion, es agregado a este sin seguir revisando los restantes.

Como se puede observar usamos dos componentes greedys en la heurística:
La primera esta cuando se ordenan las aritas decrecientemente y se crean los $k$ conjuntos a medida que se separan los nodos de las aristas de mayor peso, para que estos no generen aristas intraparticion.
La segunda componente greedy se encuentra cuando al finalizar de crear los $k$ conjuntos se recorre nodo por nodo verificando si ya se encuentra agregado y en caso negativo, verificando en que conjunto genera menos peso para finalmente agregarlo a este.

A modo de ejemplo presentamos algunas imagenes para mostrar el funcionamiento de la heuristica:

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.4]{./img/greedy1.png}
\caption{(1) Grafo de ejemplo}
\end{center}
end{figure}
La primer imagen corresponde al grafo al que se le aplicará k-PMP (1)

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.4]{./img/greedy2.png}
\caption{(2) Conjuntos 1 y 2 luego de separar los nodos de las aristas mas pesadas}
\end{center}
end{figure}
Luego de ordenar las aristas escoge las de mayor tamaño y separa sus nodos en k conjuntos k=2 para este ejemplo. (2)

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.4]{./img/greedy3.png}
\caption{(3) Conjuntos luego de comenzar a ingresar los nodos restantes}
\end{center}
end{figure}
Luego como ya hay 2 conjuntos creados procede a verificar nodo los nodos y agregandolos al conjunto que menos sume. En el caso del nodo 1, se agrega de inmediato al primer conjunto porque no genera arista intraparticion. Para el nodo 2 primero verifica en el 1er conjunto, aqui sumaria 2 de peso, se verifica en el siguiente conjunto, y como no suma peso, se ingresa ahí. (3)

\begin{figure}[H]
\begin{center}
\includegraphics[scale=0.4]{./img/greedy4.png}
\caption{(4) Resultado de haber corrido la heuristica greedy al grafo (1)}
\end{center}
end{figure}
Finalmente resta agregar el nodo 3 el cual genera en el conjunto uno un peso igual a 5, y en el conjunto 2 un peso igual a 7 al unirse con los nodos 2 y 4. Por lo tanto el nodo 3 es introducido en el conjunto 1. (4)


A continuación presentamos un pseudo-grafico del algoritmo
\begin{itemize}
\item ordenar $aristas$ por peso en orden decreciente
\item mientras restan $aristas$ 
  \begin{itemize}
  \item si no hay $k$ conjuntos, crear conjunto y agregar $nodo1$ de $arista$ (si este no pertenece a ningún conjunto)
  \item sino cortar el ciclo  
  \item si no hay $k$ conjuntos, crear conjunto y agregar $nodo2$ de $arista$ (si este no pertenece a ningún conjunto)
  \item sino cortar el ciclo  
  \end{itemize}
\item Si hay menos de $k$ conjuntos creados
  \begin{itemize}
  \item agregar las aristas que quedaron fuera a alguno de los conjuntos creados
  \end{itemize}
\item Sino
  \begin{itemize}
  \item desde nodo 0 a nodo n-1
    \begin{itemize}
    \item si el nodo no esta en ningún conjunto
      \begin{itemize}
        \item verificar conjunto por conjunto cuanto peso generaría agregarlo a este
        \item agregar el nodo al conjunto en el que genere menos peso
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}




\subsection{Analisis de complejidad}

Vamos a analizar el codigo paso por paso analizando la complejidad temporal del peor caso.
Lo primero que hacemos es ordernar las aristas, para esto utilizamos la funcion $sort$ de la $std$ que posee una complegidad temporal de $O(n.log(n))$, en este caso como se aplica a las aristas esto es $O(m.log(m))$ siendo $m$ la cantidad de aristas.
A continuación, y haciendo uso del psudo-codigo proporcionado:
\begin{itemize}
\item mientras restan $aristas$ 
  \begin{itemize}
  \item si no hay $k$ conjuntos, crear conjunto y agregar $nodo1$ de $arista$ (si este no pertenece a ningún conjunto)
  \item sino cortar el ciclo  
  \item si no hay $k$ conjuntos, crear conjunto y agregar $nodo2$ de $arista$ (si este no pertenece a ningún conjunto)
  \item sino cortar el ciclo  
  \end{itemize}
\end{itemize}
Este scope tiene una complejidad $O(m)$ ya que se recorren todas las aritas, en el peor caso creando conjuntos y agregandolos a estos, pero estas dos acciones tienen una complejidad constante.

A continuacion si se crearon menos de $k$ conjuntos se agregan los nodos que restan a uno de estos. En el peor caso esto pertenece al orden de $O(n)$ siendo n la cantidad de nodos.
Si hay $k$ conjuntos creados se procede de la siguiente manera:
\begin{itemize}
\item desde nodo 0 a nodo n-1   $O(n)$
  \begin{itemize}
  \item si el nodo no esta en ningún conjunto $O(1)$
    \begin{itemize}
      \item verificar conjunto por conjunto cuanto peso generaría agregarlo a este $O(k+n)$
      \item agregar el nodo al conjunto en el que genere menos peso $O(1)$
    \end{itemize}
  \end{itemize}
\end{itemize}



\subsection{Instancias desfavorables}


\subsection{Experimentacion}


%\begin{figure}[H]
%\begin{center}
%\includegraphics[scale=0.4]{./imagenes/ej1_chartRendimiento.png}
%\caption{Gr\'afico de tiempos con test pseudo-aleatorios.}
%\end{center}
%end{figure}
